#Download when running bot for the first time
#nltk.download("punkt") #Necessary for tokenizing text

#Chatbot Libraries
import nltk
import numpy as np
import tflearn #Deep learning library (Uses neural networks)
import tensorflow as tf #Numerical computation library to make machine learning and neural networks faster
import json
import pickle
import random
from nltk.stem.lancaster import LancasterStemmer

#GUI libraries
import tkinter as tk
from tkinter import scrolledtext
from PIL import Image, ImageTk  

#Create empty arrays
words = []
labels = []
x_docs = []
y_docs = []
training = []
output = []

#Define other variables
stemmer = LancasterStemmer()

#File with training patterns and responses (Very basic format). A.K.A. Dictionary for the bot.
with open('intents.json') as intents:
  data = json.load(intents)

# getting info from intents.json and tokenize it to compare it with the user input in runtime
for intent in data['intents']:
    for pattern in intent['patterns']:
        wrds = nltk.word_tokenize(pattern) #Tokenize the pattern (Ways that users usually inputs something)
        words.extend(wrds) #Use extend instead of append, because multiple elements will be added
        x_docs.append(wrds)
        y_docs.append(intent['tag'])

        if intent['tag'] not in labels:
            labels.append(intent['tag'])
        
#Stem the words and removing duplicate elements.
words = [stemmer.stem(w.lower()) for w in words if w not in "?"] #Applies the stemming (Example: Runners, running, runners become run)
words = sorted(list(set(words))) #Removes duplicates 
labels = sorted(labels)

arrEmpty = [0 for _ in range(len(labels))] #Each element is set to 0

#Converts categorical data into numerical data (One-hot encoding)
for x, doc in enumerate(x_docs):
    bag = []
    wrds = [stemmer.stem(w) for w in doc]
    for w in words:
        if w in wrds:
            bag.append(1)
        else:
            bag.append(0)


    arrOut = arrEmpty[:]
    arrOut[labels.index(y_docs[x])] = 1

    training.append(bag)
    output.append(arrOut)


training = np.array(training)
output = np.array(output)

#Implement the neural network
net = tflearn.input_data(shape = [None, len(training[0])])

#The next 3 lines of code adds fully connected hidden layers with 10 neurons to the network.
#Neurons are interconnected nodes or components within a Artificial Neural Network.
net = tflearn.fully_connected(net, 10) 
net = tflearn.fully_connected(net, 10)
net = tflearn.fully_connected(net, 10)
net = tflearn.fully_connected(net, len(output[0]), activation = 'softmax')
net = tflearn.regression(net) #Specific learning algorithm to use for the network

#Create training model
model = tflearn.DNN(net) #Creates deep neural network (DNN) model using the above architecture
model.fit(training, output, n_epoch = 500, batch_size = 8, show_metric = True) #Trains the network using 'training'
model.save('model.tflearn') #Saves this training to the 'model.tflearn' file

#Convert input string to bag-of-words
def bag(s, words):
    bag = [0 for _ in range(len(words))]
    sWords = nltk.word_tokenize(s)
    sWords = [stemmer.stem(word.lower()) for word in sWords]

    for s_word in sWords:
        for i, w in enumerate(words):
            if w == s_word:
                bag[i] = 1

    return np.array(bag)

#Create the GUI
def GUI():
    #Main window
    window = tk.Tk()
    window.configure(bg = 'black')
    window.title("Wall-E")
    window.geometry("700x800")
    window.lift() #Should bring the main window to the front

    #Create chat window and make it look fancy
    outChat = scrolledtext.ScrolledText(window, wrap = tk.WORD, width = 50, height = 25, bg = 'black', fg = 'white')
    outChat.config(bg = 'black', fg = 'white', highlightbackground = 'orange', highlightthickness = 2)
    outChat.tag_config('Wall-E', foreground = 'orange') #Change chatbot response colour in output to orange
    outChat.tag_config('You', foreground = 'white') #Keep your input colour white in the output window
    outChat.pack(padx = 10, pady = 10)

    # Create the input field
    fldInput = tk.Entry(window, width = 40, bg = 'black', fg = 'white')
    fldInput.pack(side = tk.LEFT, padx = 10, pady = 10)
    fldInput.config(bg = 'black', insertbackground = 'white', fg = 'white', highlightbackground = 'orange', highlightthickness = 2)
    fldInput.focus()

    # Create the send button
    def send():
        # Get the user input
        inUser = fldInput.get() 
        fldInput.delete(0, tk.END) #Clear the input field

        # Get the chatbot's response
        results = model.predict([bag(inUser, words)])
        ixRes = np.argmax(results)
        tag = labels[ixRes]

        for tg in data['intents']:
            if tg['tag'] == tag:
                responses = tg['responses']
                botResponse = random.choice(responses)
                outChat.insert(tk.END, "You: " + inUser + "\n", 'You')

        # Display the user input (White) and chatbot response (Orange) in the output window
        outChat.insert(tk.END, "Wall-E: " + botResponse + "\n\n", 'Wall-E')     

    #Add a image to be used as a send button (Only for aesthetics)
    imgSend = Image.open('Send Button.png')
    imgSend = imgSend.resize((35, 35), Image.ANTIALIAS)
    imgSend = ImageTk.PhotoImage(imgSend) 

    btnSend = tk.Button(window, image = imgSend, command = send, bd = 0, highlightthickness = 0, bg = 'gray16')
    btnSend.pack(side = tk.LEFT, padx = 10, pady = 10)

    #Bind the 'Enter' key to the send button
    def on_enter(event):
        btnSend.invoke()
    
    window.bind('<Return>', on_enter)

    # Start the GUI event loop
    window.mainloop()

def chat():
    GUI()

chat()
